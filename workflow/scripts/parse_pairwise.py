#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Mon May  6 13:52:09 2019
@author: hershe

Modified on Mon March 17 2025
@author: Alec Barrett

Takes as input a file with pairwise alignments generated by
the C++ sam2pairwise utility written by Matthew C. LaFave.

Creates a data frame that has the necessary features for my
preprocessing pipeline for model predictions.

Written for use in a Snakemake pipeline.

(written to be faster than parse_pairwise.py by make all the rows, and then
only creating a dataframe once.)

(written to be faster than parse_pairwise2.py by not iterating over the rows
in the data frame to add alignment scores.)

Note from Alec 20250317
(written to take the previous code and have it write to a new file probe by probe
because currently single large chromosomes can take > 60GB ram to run)

"""

import pandas as pd
import itertools
import csv
import gc
import re


# compute whether or not the alignment is on target
def on_target(row):
    if (row['probe_ID'].split(':')[0] == str(row['align_chr'])) & \
       (row['probe_ID'].split(':')[1].split('-')[0] ==  str(row['align_start'])):
           return 1
    else:
           return 0

### initialize useful values
current_probe_value = None
alignment_n = 0

rows_list = []

#### start csv outfile
headers = ['probe_ID',
            'parent',
            'derived',
            'align_chr',
            'align_start',
            'bowtie',
            'on_target']

### initialize output file
### initialize useful values
current_probe_value = None
alignment_n = 0

rows_list = []

#### start csv outfile
headers = ['probe_ID',
            'parent',
            'derived',
            'align_chr',
            'align_start',
            'bowtie',
            'on_target']


buffer_size = 10_000

with open(snakemake.output[0], 'w', newline='') as csvfile:
    writer = csv.writer(csvfile)
    writer.writerow(headers)

    ### loop through groups of 4 lines in alignment file, and grab 1 line per 4 from the AS score file
    with open(snakemake.input[0], 'r') as f, open(snakemake.input[1], 'r') as g:


        for probe_ID, parent, aligns, reference in itertools.zip_longest(*[f]*4):
            score_line = g.readline()
            score = score_line.split(':')[2].strip()

            ## extract the probe name from the probe_ID line
            probe_parts = probe_ID.split('\t')
            probe_value = probe_parts[0]
            align_chr = probe_parts[2] if len(probe_parts) > 2 else ""
            align_start = probe_parts[3] if len(probe_parts) > 3 else ""
            ## initialize on_target as "no"
            on_target = 0
            real_chr, real_start = re.split(r':|-', probe_value)[0:2]

            ### check if the probe is on_target
            if real_chr == align_chr and real_start == align_start:
                on_target = 1
            
            ### if this is the first line, initiate a rowlist
            if current_probe_value is None:
                current_probe_value = probe_value
                alignment_n = 0
                rows_list = []

            ### if too many alignments, delete the contents of the row list, and skip this set
            if alignment_n >= 100:
                if probe_value == current_probe_value:
                    continue
                else:
                    # New probe, reset counters but don't process the previous one
                    current_probe_value = probe_value
                    alignment_n = 0
                    rows_list = []
                    #gc.collect()
            

            ### if finding new probe id, bundle the last batch of records and write it to csv
            if probe_value != current_probe_value and alignment_n < 100:
                if rows_list:
                    for row in rows_list:
                        writer.writerow(row)
                    csvfile.flush()
                ### reset values
                current_probe_value = probe_value
                alignment_n = 0
                rows_list = []

            
            ### if the probe wasn't caught as invalid, write its information to a tuple
            if probe_value == current_probe_value and alignment_n < 100:
                alignment_n +=1

                #row_dict = {}
                #row_dict.update(probe_ID = probe_value,
                #                parent = str(parent.strip()),
                #                derived = str(reference.strip()),
                #                align_chr = align_chr,
                #                align_start =align_start,
                #                bowtie = score,
                #                on_target = on_target)
                #rows_list.append(row_dict)
                row_data = (probe_value, str(parent.strip()), str(reference.strip()),
                            align_chr, align_start, score, on_target)
                rows_list.append(row_data)



    ## after the inner loop, check if there's a straggler probe, and write it if it's not too long
    if rows_list and alignment_n < 100:
        for row in rows_list:
                        writer.writerow(row)


